import { existsSync, writeFileSync, readFileSync } from 'fs'
import { join } from 'path'
import { homedir } from 'os'
import { app } from 'electron'
import { getAppDataPath, ensureDir } from '@main/storage/storage-manager'

const HOOK_FILENAME = app.isPackaged ? 'wsidn-session-hook.mjs' : 'wsidn-dev-session-hook.mjs'

/**
 * Creates the hook script at %APPDATA%/wsidn/hooks/wsidn-session-hook.mjs.
 * Called by Claude Code's SessionStart and Stop hooks.
 * Usage: node wsidn-session-hook.mjs [start|stop]
 */
export function setupHookScript(): void {
  const hooksDir = getAppDataPath('hooks')
  ensureDir(hooksDir)

  const hookPath = join(hooksDir, HOOK_FILENAME)
  const portFilePath = getAppDataPath('hook-server-port.json')

  const script = `#!/usr/bin/env node
// Auto-generated by WSIDN — do not edit manually.
// Called by Claude Code hooks (SessionStart / SessionEnd / UserPromptSubmit).
// Usage: node wsidn-session-hook.mjs [start|stop|prompt]

import { readFileSync } from 'fs';
import http from 'http';

const TIMEOUT_MS = 2000;
const PORT_FILE = ${JSON.stringify(portFilePath.replace(/\\/g, '/'))};

async function main() {
  const hookType = process.argv[2] || 'start'; // "start", "stop", or "prompt"

  // Only run inside WSIDN PTY
  const wsidnSessionId = process.env.WSIDN_PTY_ID;
  if (!wsidnSessionId) process.exit(0);

  // Read stdin (Claude provides JSON)
  let input = '';
  try {
    input = readFileSync(0, 'utf-8');
  } catch {
    process.exit(0);
  }

  let data;
  try {
    data = JSON.parse(input);
  } catch {
    process.exit(0);
  }

  // Read port file
  let portInfo;
  try {
    portInfo = JSON.parse(readFileSync(PORT_FILE, 'utf-8'));
  } catch {
    process.exit(0);
  }

  let payload;
  let endpoint;

  if (hookType === 'prompt') {
    const promptText = data.prompt || data.message || '';
    if (!promptText) process.exit(0);
    payload = JSON.stringify({
      wsidn_session_id: wsidnSessionId,
      prompt: promptText,
    });
    endpoint = '/hook/prompt-submit';
  } else {
    payload = JSON.stringify({
      wsidn_session_id: wsidnSessionId,
      claude_session_id: data.session_id || null,
      source: hookType === 'stop' ? 'stop' : (data.hook_type || data.source || 'startup'),
      model: data.model || ''
    });
    endpoint = hookType === 'stop' ? '/hook/session-stop' : '/hook/session-start';
  }

  return new Promise((resolve) => {
    const timer = setTimeout(() => resolve(), TIMEOUT_MS);

    const req = http.request({
      hostname: '127.0.0.1',
      port: portInfo.port,
      path: endpoint,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(payload) }
    }, () => {
      clearTimeout(timer);
      resolve();
    });

    req.on('error', () => {
      clearTimeout(timer);
      resolve();
    });

    req.write(payload);
    req.end();
  });
}

main().then(() => process.exit(0)).catch(() => process.exit(0));
`

  writeFileSync(hookPath, script, 'utf-8')
}

type HookEntry = {
  matcher?: string
  hooks?: Array<{ type: string; command: string }>
}

/**
 * Registers hooks in ~/.claude/settings.json so Claude Code
 * calls our script on SessionStart and Stop events.
 */
export function setupClaudeSettings(): void {
  const hookPath = getAppDataPath('hooks', HOOK_FILENAME).replace(/\\/g, '/')
  const startCommand = `node "${hookPath}" start`
  const stopCommand = `node "${hookPath}" stop`
  const promptCommand = `node "${hookPath}" prompt`

  const claudeDir = join(homedir(), '.claude')
  ensureDir(claudeDir)

  const settingsPath = join(claudeDir, 'settings.json')

  // Read existing settings or start fresh
  let settings: Record<string, unknown> = {}
  if (existsSync(settingsPath)) {
    try {
      settings = JSON.parse(readFileSync(settingsPath, 'utf-8'))
    } catch {
      // Corrupted file — preserve nothing
    }
  }

  if (!settings.hooks || typeof settings.hooks !== 'object') {
    settings.hooks = {}
  }

  const hooks = settings.hooks as Record<string, unknown>
  let changed = false

  // Register SessionStart hook
  changed = ensureHookEntry(hooks, 'SessionStart', startCommand) || changed

  // Register SessionEnd hook (fires when session truly terminates, not per-turn)
  changed = ensureHookEntry(hooks, 'SessionEnd', stopCommand) || changed

  // Register UserPromptSubmit hook (fires when user submits a prompt)
  changed = ensureHookEntry(hooks, 'UserPromptSubmit', promptCommand) || changed

  // Migrate: remove old Stop hook (was incorrectly used instead of SessionEnd)
  changed = removeStaleHookEntry(hooks, 'Stop') || changed

  if (changed) {
    writeFileSync(settingsPath, JSON.stringify(settings, null, 2), 'utf-8')
  }
}

function ensureHookEntry(
  hooks: Record<string, unknown>,
  eventName: string,
  command: string
): boolean {
  if (!Array.isArray(hooks[eventName])) {
    hooks[eventName] = []
  }

  const entries = hooks[eventName] as HookEntry[]

  // Already registered with the correct command — nothing to do
  if (entries.some((entry) => entry.hooks?.some((h) => h.command === command))) return false

  // Registered with a stale path (same filename, different path) — update in place
  const staleEntry = entries.find((entry) =>
    entry.hooks?.some((h) => h.command.includes(HOOK_FILENAME))
  )
  if (staleEntry) {
    staleEntry.hooks = staleEntry.hooks!.map((h) =>
      h.command.includes(HOOK_FILENAME) ? { ...h, command } : h
    )
    return true
  }

  entries.push({
    matcher: '',
    hooks: [{ type: 'command', command }]
  })

  return true
}

/** Remove our hook entries from a stale event name (migration helper). */
function removeStaleHookEntry(
  hooks: Record<string, unknown>,
  eventName: string
): boolean {
  if (!Array.isArray(hooks[eventName])) return false

  const entries = hooks[eventName] as HookEntry[]
  const filtered = entries.filter(
    (entry) => !entry.hooks?.some((h) => h.command.includes(HOOK_FILENAME))
  )

  if (filtered.length === entries.length) return false

  if (filtered.length === 0) {
    delete hooks[eventName]
  } else {
    hooks[eventName] = filtered
  }
  return true
}
